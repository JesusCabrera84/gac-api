name: Deploy to EC2

on:
  push:
    branches:
      - master
  workflow_dispatch: # Permite ejecuci√≥n manual

env:
  IMAGE_NAME: gac-api
  IMAGE_TAG: ${{ github.sha }}
  CONTAINER_NAME: gac-api

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    environment: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install linting dependencies
        run: |
          python -m pip install --upgrade pip
          pip install ruff black

      - name: Run Ruff (linter)
        run: |
          echo "üîç Ejecutando Ruff..."
          ruff check app/

      - name: Run Black (formatter)
        run: |
          echo "üé® Verificando formato con Black..."
          black --check app/ || echo "‚ö†Ô∏è Hay problemas de formato, pero continuamos con el deployment"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          tags: gac-api:latest
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Save Docker image
        run: |
          docker save gac-api:latest | gzip > gac-api.tar.gz

      - name: Copy files to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_SSH_PORT }}
          source: "gac-api.tar.gz,docker-compose.prod.yml"
          target: "/home/${{ secrets.EC2_USERNAME }}/gac-api"

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        env:
          IMAGE_NAME: gac-api
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          PORT: ${{ vars.PORT }}
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          PASETO_SECRET_KEY: ${{ secrets.PASETO_SECRET_KEY }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_SSH_PORT }}
          envs: IMAGE_NAME,CONTAINER_NAME,PORT,DB_HOST,DB_PORT,DB_USER,DB_PASSWORD,DB_NAME,JWT_SECRET,PASETO_SECRET_KEY
          script: |
            cd /home/${{ secrets.EC2_USERNAME }}/gac-api

            # Cargar la nueva imagen
            echo "üì¶ Cargando nueva imagen Docker..."
            docker load < gac-api.tar.gz

            # Crear la red si no existe
            docker network inspect siscom-network >/dev/null 2>&1 || docker network create siscom-network

            # Crear archivo .env con las variables
            echo "üîß Configurando variables de entorno..."
            cat > .env << EOF
            PORT=${PORT}
            DB_HOST=${DB_HOST}
            DB_PORT=${DB_PORT}
            DB_USER=${DB_USER}
            DB_PASSWORD=${DB_PASSWORD}
            DB_NAME=${DB_NAME}
            JWT_SECRET=${JWT_SECRET}
            PASETO_SECRET_KEY=${PASETO_SECRET_KEY}
            EOF

            # Detener y eliminar el contenedor existente de forma robusta
            echo "üõë Deteniendo contenedores anteriores..."

            # Intentar detener con docker-compose
            docker-compose -f docker-compose.prod.yml down || true

            # Forzar detenci√≥n de contenedor por nombre si existe
            if docker ps -a | grep -q ${CONTAINER_NAME}; then
              echo "Deteniendo contenedor ${CONTAINER_NAME}..."
              docker stop ${CONTAINER_NAME} || true
              docker rm ${CONTAINER_NAME} || true
            fi

            # Verificar si el puerto est√° en uso y liberar si es necesario
            USED_PORT=$(docker ps -q --filter "publish=${PORT}" || true)
            if [ ! -z "$USED_PORT" ]; then
              echo "‚ö†Ô∏è Puerto ${PORT} en uso por contenedor(es): $USED_PORT"
              echo "Deteniendo contenedor(es) que usan el puerto ${PORT}..."
              docker stop $USED_PORT || true
              docker rm $USED_PORT || true
            fi

            # Limpiar contenedores hu√©rfanos y redes no usadas
            echo "üßπ Limpiando recursos hu√©rfanos..."
            docker-compose -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true

            # Levantar el nuevo contenedor
            echo "üöÄ Levantando nuevo contenedor..."
            docker-compose -f docker-compose.prod.yml up -d --remove-orphans

            # Esperar un momento para que el contenedor se inicie
            sleep 5

            # Verificar que el contenedor se cre√≥ correctamente
            if ! docker ps | grep -q ${CONTAINER_NAME}; then
              echo "‚ùå ERROR: El contenedor ${CONTAINER_NAME} no est√° corriendo"
              echo "Contenedores activos:"
              docker ps -a
              echo ""
              echo "Logs del contenedor (si existe):"
              docker logs ${CONTAINER_NAME} 2>&1 || echo "No se pudo obtener logs"
              exit 1
            fi

            # Esperar a que el contenedor est√© saludable
            echo "‚è≥ Esperando a que el contenedor est√© saludable..."
            CONTAINER_HEALTHY=false
            for i in {1..30}; do
              # Verificar que el contenedor sigue corriendo
              if ! docker ps | grep -q ${CONTAINER_NAME}; then
                echo "‚ùå ERROR: El contenedor se detuvo inesperadamente"
                echo "Logs del contenedor:"
                docker logs --tail 100 ${CONTAINER_NAME}
                exit 1
              fi
              
              STATUS=$(docker inspect --format="{{.State.Health.Status}}" ${CONTAINER_NAME} 2>/dev/null || echo "no_health_check")
              echo "Intento $i/30: Status = $STATUS"
              
              if [ "$STATUS" = "healthy" ]; then
                echo "‚úÖ Contenedor est√° healthy!"
                CONTAINER_HEALTHY=true
                break
              elif [ "$STATUS" = "unhealthy" ]; then
                echo "‚ùå ERROR: Contenedor est√° unhealthy"
                echo "Logs del contenedor:"
                docker logs --tail 50 ${CONTAINER_NAME}
                exit 1
              elif [ "$STATUS" = "no_health_check" ]; then
                echo "‚ö†Ô∏è No hay health check configurado, asumiendo que est√° OK"
                CONTAINER_HEALTHY=true
                break
              fi
              
              sleep 2
            done

            if [ "$CONTAINER_HEALTHY" = false ]; then
              echo "‚ùå ERROR: Timeout esperando que el contenedor est√© healthy"
              echo "Estado actual: $(docker inspect --format="{{.State.Status}}" ${CONTAINER_NAME})"
              echo "Logs del contenedor:"
              docker logs --tail 50 ${CONTAINER_NAME}
              exit 1
            fi

            # Verificar logs en busca de errores cr√≠ticos
            echo "üîç Verificando logs en busca de errores..."
            if docker logs ${CONTAINER_NAME} 2>&1 | grep -q "Application startup failed"; then
              echo "‚ùå ERROR: La aplicaci√≥n fall√≥ al iniciar"
              docker logs --tail 50 ${CONTAINER_NAME}
              exit 1
            fi

            # Limpiar im√°genes antiguas
            echo "üßπ Limpiando im√°genes antiguas..."
            docker image prune -f

            # Eliminar el archivo tar.gz
            rm -f gac-api.tar.gz

            echo "‚úÖ Deployment completado exitosamente!"

      - name: Verify deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_SSH_PORT }}
          script: |
            echo "=== Verificaci√≥n Final del Deployment ==="
            echo ""

            # Verificar que el contenedor est√° corriendo
            echo "1. Estado del contenedor:"
            if ! docker ps | grep gac-api; then
              echo "‚ùå ERROR: El contenedor gac-api no est√° corriendo"
              exit 1
            fi
            echo "‚úÖ Contenedor corriendo"
            echo ""

            # Verificar health status
            echo "2. Health status:"
            HEALTH_STATUS=$(docker inspect --format="{{.State.Health.Status}}" gac-api)
            echo "Status: $HEALTH_STATUS"
            if [ "$HEALTH_STATUS" != "healthy" ]; then
              echo "‚ùå ERROR: Contenedor no est√° healthy"
              exit 1
            fi
            echo "‚úÖ Contenedor healthy"
            echo ""

            # Verificar que no hay errores cr√≠ticos en logs
            echo "3. Verificando logs recientes:"
            RECENT_LOGS=$(docker logs --tail 50 gac-api 2>&1)

            if echo "$RECENT_LOGS" | grep -q "Application startup failed"; then
              echo "‚ùå ERROR: Aplicaci√≥n fall√≥ al iniciar"
              echo "$RECENT_LOGS"
              exit 1
            fi

            if echo "$RECENT_LOGS" | grep -q "ModuleNotFoundError"; then
              echo "‚ùå ERROR: M√≥dulo faltante"
              echo "$RECENT_LOGS"
              exit 1
            fi

            if echo "$RECENT_LOGS" | grep -E "ERROR.*Exiting" | grep -v "test"; then
              echo "‚ùå ERROR: Error cr√≠tico encontrado en logs"
              echo "$RECENT_LOGS"
              exit 1
            fi

            echo "‚úÖ No se encontraron errores cr√≠ticos"
            echo ""

            # Verificar que el health endpoint responde
            echo "4. Verificando health endpoint:"
            CONTAINER_IP=$(docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' gac-api)
            APP_PORT=$(docker exec gac-api printenv PORT 2>/dev/null || echo "8000")
            if curl -f -s http://localhost:${APP_PORT}/health > /dev/null 2>&1 || curl -f -s http://$CONTAINER_IP:${APP_PORT}/health > /dev/null 2>&1; then
              echo "‚úÖ Health endpoint responde correctamente en puerto ${APP_PORT}"
            else
              echo "‚ö†Ô∏è  Warning: No se pudo verificar el health endpoint (puede ser normal si hay firewall)"
            fi
            echo ""

            echo "üéâ Deployment verificado exitosamente!"
            echo ""
            echo "=== √öltimos logs (informativos) ==="
            docker logs --tail 20 gac-api

      - name: Notification on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed! Check the logs above for details."
          # Aqu√≠ puedes agregar notificaciones a Slack, Discord, email, etc.
